- C++ 代码 面对大量数据 读取 输出作，最好用scanf 和 printf，耗时会小很多
- scanf 返回值
  
      scanf 函数返回成功读取的输入项的数量：
          如果成功读取两个整数，则返回 2。
          如果没有读取任何有效的输入（例如，用户输入格式错误），则返回 0。
          如果发生其他错误（比如文件结束），则可能返回 EOF，通常是 -1。
      按位取反 ~
          按位取反运算符 ~ 对返回值进行按位取反的效果如下：
          当 scanf 成功读取两个整数时：
              返回值 2 经过取反后变为 ~2，这里的计算是 -3（在二进制下，2 为 0000 0010，取反后变为 1111 1101，即 -3）。
              -3 被视为真值，因此 while 循环继续执行。
          当 scanf 没有读取任何有效输入（返回 0）时：
              取反后的值为 ~0 变成 -1，也被视为真值，循环还会继续。
          当 scanf 遇到输入错误或者到达输入流的末尾返回 EOF（通常是 -1）时：
              取反后的值为 ~(-1) 变为 0，这使得 while 条件为假，从而退出循环。
      因此可用while(~scanf("%d",&a))来进行循环输入
- ``INT_MAX``、 ``INT_MIN``会用到头文件 ``#include <climits>``
- 求绝对值 ``x = abs();``
- stl对于``std::vector< bool>``进行了模板特化，其行为和性能不如其它容器一致，应当避免使用。  
  可以适当替换为``std::vector< char>，std::vector<uint8_t>, std::bitset``。
- ``void *memset(void *str, int c, size_t n)`` 用于将一段内存区域设置为指定的值。(在清空内存区域或者为内存区域赋值时)
  ```
  void *memset(void *str, int c, size_t n)
  ```
  eg: memset(next, 0, sizeof(next)); // 将next数组初始化为nullptr
- lambda函数写法``头文件#include <funtional> #include <algorithm>``
  1. ![image](https://github.com/user-attachments/assets/d482aa76-6432-4e9b-bee7-a512b433b5ed)
     占用内存小 ，快  
     其实这里的 ``-> void`` 可以省略 ， 但如果是其他的返回值就不能省略了
  3. ![image](https://github.com/user-attachments/assets/ec2b2917-df9d-47f7-aeb2-7e8208cadceb)
     占用内存大
- 转换字母大小写
  ```
  char c = 'a';
  c = toupper(c);
  char c = 'A';
  c = tolower(c);

  c ^= 32;(异或操作 ， 能将大写转换为小写 ， 小写转换为大写)。
  ```
- 检查字母类型
    - ``isdigit(c)`` 检查是否是数字
    - ``isalpha(c)`` 检查是否是字母
- bitset 位图
    - 位图是一种直接定址法的哈希，因此效率很高，用O(1)就可以探测到对应位是0还是1，效率非常高。
- const & constexpr
    - 修饰对象时
  
          const修饰一个对象表示它是常量。这暗示对象一经初始化就不会再变动了，并且允许编译器使用这个特点优化程序。这也防止程序员修改了本不应该修改的对象。
          constexpr是修饰一个常量表达式。但请注意constexpr不是修饰常量表达式的唯一途径。因为const也可以修饰常量表达式。
          (PS: 常量表达式：必须是可以在编译阶段被识别的。比如模版的参数／数组的大小。)
    - 修饰函数时
 
          const只能用于非静态成员的函数而不是所有函数。它保证成员函数不修改任何非静态数据成员（可变数据成员除外，任何情况都可修改）。
          constexpr可以与成员函数、非成员函数、构造函数一起使用。constexpr函数适用于常量表达式，只有在下面的情况下编译器才会接受constexpr函数：
          1.函数体必须足够简单，除了typedef和静态元素，只允许有return语句。如构造函数只能有初始化列表，typedef和静态元素 (实际上在C++14标准中已经允许定义语句存在于constexpr函数体内了)
          2.参数和返回值必须是字面值类型
     - 不同的指向
       ```
       static constexpr int N = 3;
       int main()
       {
          constexpr const int *NP = &N; // 或者写成 constexpr int const *NP = &N;
          return 0;
       }
       ```
       在这里constexpr和const都必须要有。constexpr表示NP指针本身是常量表达式，而const表示指向的值是一个常量。去掉const之后无法编译，因为不能用正常指针指向常量。
     - 根本区别
       ```
       int temp=rand(); // temp is generated by the the random generator at runtime.

       const int x1=10; // OK - known at compile time.
       const int x2=temp; // OK - known only at runtime.
       constexpr int x3=10; // OK - known at compile time.
       constexpr int x4=temp; // ERROR. Compiler can't figure out the value of 'temp' variable at compile time so `constexpr` can't be applied here.
       ```
       const变量的值可以在编译时和运行时得到，但constexpr变量的值在编译时必须得到，如果要在运行时才能得到则会报错。跟其具有相似特性的有C++中数组长度的声明，也必须在编译时得到。
       ```
       int temp=rand(); // temp is generated by the the random generator at runtime.

       int array1[10]; // OK.
       int array2[temp]; // ERROR.
       ```
       ```
       constexpr int func_constexpr(int X, int Y)
       {
           return(X*Y);
       }
      
       int func(int X, int Y)
       {
           return(X*Y);
       }
      
       int array1[func_constexpr(10,20)]; // OK - func_constexpr() can be evaluated at compile time.
       int array2[func(10,20)]; // ERROR - func() is not a constexpr function.
      
       int array3[func_constexpr(10,rand())]; // ERROR - even though func_constexpr() is the 'constexpr' function, the expression 'constexpr(10,rand())' can't be evaluated at compile time.
       ```
- 整数转化为小数
    - 隐式转换 ``num*1.0``
    - 强制转换 ``static_cast<float>(num)``
- 读取string类型
    scanf 不能直接读取 ``std::string`` 类型。只能使用字符数组（char[]）来接收输入。
      ```
      char s[20];
      scanf("%s" , s);
      ```
    或者使用 ``std::cin`` 直接读取 string 类型。PS：cin和scanf都读取的是不含空格的字符串。
- 根据vector数组中的某一项进行排序：  
  使用 ``std::sort`` 函数来对 rec 进行排序。我们传入 rec.begin() 和 rec.end() 来指定排序的范围。  
  使用 lambda 表达式作为第三个参数来定义排序的规则。
  ```
  #include <vector>
  #include <algorithm>
  #include <iostream>
  using namespace std;

  int main(){
    vector<vector<int>> rec(5 , vector<int>(3 , 0));
    sort(rec.begin() , rec.end() , [](const vector<int>& a , const vector<int>& b){
      return a[1] > b[1]; // 按降序排
    });//根据rec[i][1]的值进行排序
  }
  ```
  - 对于基本类型（如 int、char），直接传值更高效，但对于 ``std::string`` 这种可能包含动态内存的对象，传引用更优。
  - 头文件``#include <sstream>``用法
    1. istringstream
       用于从字符串中读取数据（像stoi()）
       ```
       string data = "12 12.1";
       istringstream iss(data);
       int num1;
       double num2;
       iss >> num1 >> num2;
       ```
    2. ostringstream
       用于将数据写入字符串（像to_string()）
       ```
       ostringstream oss;
       int num = 1;
       double f = 2.32;
       oss << i << " " << f;
       string res = oss.str();
       // res = "1 2.32";
       ```
    3. stringstream
       stringstream是istringstream和ostringstream的组合，可以同时进行读取和写入操作。
       ```
       string data = "32 3.1412";
       stringstream ss(data);
       int i;
       double d;
       ss >> i >> d;
       ss.str(); // 清空ss
       ss << "new data :" << " huawei " << 20 << 25.4;
       string res = ss.str();
       // res = "new data : huawei 2025.4";
       ```
- 有序容器都适用的：
  ```
  lower_bound(nums.begin(),nums.end(),target)大于等于的第一个
  upper_bound(nums.begin(),nums.end(),target)大于第一个
  ```
  头文件是``#include algorithm``,数组，vector，map，set都能用
- 输出指定位数的小数
  ```
  //方法一：
  double d;
  cin >> d;
  cout << fixed << setprecision(3) << d << endl;//三位小数
  ```
  fixed是强制以小数类型输出，setprecision(n)设置小数点后保留n位，自动四舍五入。  
  头文件为``#include <iomanip>``
  ```
  //方法二：
  double d;
  scanf("%lf",&d);
  printf("%.3f",d);//输出三位小数
  ```
  直接使用C风格输入输出
- 输出指定位数的整数，不足前面补零
  ```
  //方法一：
  int n;
  cin >> n;
  cout << setw(9) << setfill('0') << n << endl;
  ```
  setw表示指定输出宽度，setfill('0')用零填充左侧空缺；
  ```
  //方法二：
  int n;
  scanf(%d , &n);
  print("%09d", n);
  ```
  C风格
- 查看变量类别
  ```
  typeid(var).name();
  ```
- 生成随机数
  - rand()产生的随机数在每次运行的时候都是与上一次相同的，这是有意这样设计的，是为了便于程序的调试。
  - 如果要生成每次不同的随机数，可以采用srand(seed)函数生成随机种子
     ```
     #include <iostream>
     #include <time.h>
     using namespace std;
     int main(){
       srand(time(0));//生成以当前时间开始的随机种子
       cout << rand()%11 << endl;//生成每次不重复的从0-10的随机数
     }
     ``` 
