1. 数组其实就是一张哈希表（可以把哈希表理解为一个数组）
2. 用法：哈希表用来快速判断一个元素是否出现在集合里
3. 哈希函数
  如果学生的数量大于哈希表的大小怎么办，
  此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。
4. 哈希碰撞
  一般哈希碰撞有两种解决方法， 拉链法（像链表一样加后边）和线性探测法（tablesize > datasize）。
5. 常见三种哈希结构
  · 数组
  · 集合set
      set提供三种数据结构：
      set 、 multiset 、 unordered_set 
      前两种底层实现为红黑树，后一种为哈希表。
      红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改。
      改动key值会导致整棵树的错乱，所以只能删除和增加。
      只有multiset的元素可以重复，三者都不能更改key值。
  · 映射map
      map同样提供三种数据结构，跟上面同理。
      map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。
  当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的。
  如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

  虽然std::set和std::multiset 的底层实现基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。
  不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。
  所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。std::map也是一样的道理。
哈希法是牺牲了空间换取了时间
