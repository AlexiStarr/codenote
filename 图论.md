### 概念
- 有向图
- 无向图
- 加权有向图
- 加权无向图
- 度
    - 有向图 ： 分入度、出度
    - 无向图 ： 度
- 连通性 
    - 连通图（无向任意两点可到达）  
      ![image](https://github.com/user-attachments/assets/28c98798-88bc-4f6f-a7eb-b4f5c626d0e9)
    - 强连通图（有向任意两点可到达）
    - 连通分量  
        必须是极大连通子图才能是连通分量
    - 强连通分量  
        同理，必须是极大图
- 图的构造
    - 朴素构造
        数组存储边
    - 邻接表
        数组加链表或者是二维容器也可以实现 eg: vector<vector<int>> edges;
    - 邻接矩阵
        矩阵存权值 ， 不适合稀疏图
    - 类
        例如：字典树/前缀树/单词查找树
### 题型及做题方法
- dfs —— 递归/栈（递归本身也是依靠栈实现的 —— 后进先出）
- bfs —— 队列（先进先出）
- 并查集
- 静态常量数组设置方向
  ```
  constexpr static int dx[4] = {1 , 0 , -1 , 0};
  ```
- 拓扑排序问题(Topo sort)
  - 其实dfs和bfs都可以解决
  - 对于dfs
    
    构建邻接表和visited数组
    visited为 0 表示未搜索； 为 1 表示正在搜索； 为 2 表示已搜索；
    对于一个正在搜索的节点，递归搜索依赖它的所有节点，如果有节点visited为 0 ，证明有环存在；
    搜索完后将节点visited值置为 2 。
  - 对于bfs
    
    根据依赖关系，构建邻接表、入度数组。
    选取入度为 0 的数据，根据邻接表，减小依赖它的数据的入度。
    找出入度变为 0 的数据，重复第 2 步。
    直至所有数据的入度为 0，得到排序，如果还有数据的入度不为 0，说明图中存在环。
- 前缀树/字典树/单词查找树  
  ***一次建树 ， 多次查询***
- 岛屿问题
