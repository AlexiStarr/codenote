## 字符串相关函数
1. 字符串长度 length、size
2. 反转字符串 reserve  
          ```
          reverse(s.begin() , s.end());  
          也可以只翻转一部分，在上面的基础上加减就行
          ```
4. 交换字符串中字符位置 swap
5. 对字符串进行排序 sort  
          ```
          sort(s.begin() , s.end());
          ```
7. 扩充字符串大小 resize 
8. 删除元素 erase 注意：erase的时间复杂度是O(n)
9. find函数：
       find(a) , find(a , 1)从第二个字符开始找；  
       rfind() , 倒着找；  
       如果没找到，会返回npos；  
       返回值是int类型，返回的值是字符串下标；
11. to_string 函数：将十进制数字常量转换为字符串，返回值为转换完毕的字符串  
          string s = to_string(i); //将整数i转换为字符串表示形式
12. compare函数比较两字符串是否相等  
          若参与比较的两个串值相同，则函数返回 0；若字符串 S 按字典顺序要先于 S2，则返回负值；反之，则返回正值。  
       ```  
       int result = s1.compare(s2);  
       int result = s1.compare(3, 3, s2);//从索引3开始的三个字符跟s2比较  
       const char* s2 = "hello";  
       int result = s1.compare(s2); // 比较 s1 和 C 字符串 s2  
       int result = s1.compare(3, 3, s2 , 5 , 2);
       ```
14. stoi函数将字符串转为十进制数字
           stoi（字符串，起始位置，n进制（默认10进制）），将 n 进制的字符串转化为十进制
           默认情况下，stoi 假定字符串是十进制数字。如果字符串以 "0x" 或 "0X" 开头，则会相应地解释为十六进制。
15. remove与erase结合删除指定字符
    remove并不删除元素，它只把不符合的元素前移，然后返回一个新的逻辑结尾迭代器
    ```
    s.erase(remove(s.begin() , s.end() , ' ') , s.end());//删掉s中的空格
    ```
##  ※ KMP算法
### KMP经典思想就是:
当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。
### KMP主要应用在字符串匹配上。
### next 数组是一个 _前缀表_ :
 - 前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。
 - 前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，
 - 此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。
因此，前缀表就是：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。
### 最长公共前后缀
- 字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。
- 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。
实际上是最长相等前后缀，因为前缀表要求的就是相同前后缀的长度。
### 如何计算前缀表？
![image](https://github.com/user-attachments/assets/ec15d2e7-cf95-48c1-bc94-4c3bb6acd79a)
- 可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。
- 前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。※【理解】
### next数组和前缀表
next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（**右移**一位，初始位置为-1）。
### 时间复杂度分析
其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

暴力解法是两个循环O(n * m) ， 因此效率提高很多。

变态KMP，屮
